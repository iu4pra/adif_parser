import unittest
import adif

class TestAdifParser(unittest.TestCase):

    def test_parse_simple_string(self):
        # FIXED: Changed <CALL:5> to <CALL:4> so it matches "W1AW" exactly
        data = "<CALL:4>W1AW <EOR>"
        fields = adif.parse_adif_string(data)
        
        # Expecting 2 fields: CALL and EOR
        self.assertEqual(len(fields), 2)
        self.assertEqual(fields[0]['field'], 'CALL')
        self.assertEqual(fields[0]['value'], 'W1AW') # Now this will match
        self.assertEqual(fields[1]['field'], 'EOR')

    def test_parse_complex_types(self):
        # Testing fields with data types (e.g., <FREQ:6:N>)
        data = "<FREQ:6:N>14.074 <MODE:3>FT8 <EOR>" 
        # Note: I also ensured MODE length matches "FT8" (3 chars)
        fields = adif.parse_adif_string(data)
        
        self.assertEqual(fields[0]['field'], 'FREQ')
        self.assertEqual(fields[0]['value'], '14.074')
        self.assertEqual(fields[0]['type'], 'N') # Type check

    def test_header_stripping(self):
        # Test if the parser correctly removes the header
        data = "Generated by Logger32 <EOH><CALL:5>K1ABC <EOR>"
        fields = adif.parse_adif_string(data)
        
        # Let's test the specific remove_header function
        clean_fields, eoh_index = adif.remove_header(fields)
        
        # After stripping, only CALL and EOR should remain
        self.assertEqual(clean_fields[0]['field'], 'CALL')
        self.assertEqual(clean_fields[1]['field'], 'EOR')

    def test_qso_list_creation(self):
        # Test converting raw fields into a list of QSO objects
        # FIXED: Adjusted lengths to match data (3 chars for K1A and K2B)
        data = "<CALL:3>K1A <EOR> <CALL:3>K2B <EOR>"
        fields = adif.parse_adif_string(data)
        qso_list = adif.adif_to_qso_list(fields)
        
        self.assertEqual(len(qso_list), 2)
        self.assertEqual(qso_list[0]._d['CALL'], 'K1A')
        self.assertEqual(qso_list[1]._d['CALL'], 'K2B')

if __name__ == '__main__':
    unittest.main()